Міністерство освіти і науки України
Харківський національний університет радіоелектроніки



Кафедра програмної інженерії





Звіт
з практичної роботи №2
з дисципліни  «Аналіз та рефакторінг коду»
на тему «Методи рефакторингу коду програмного забезпечення»





Виконала:						    Перевірив:
Ст. гр. ПЗПІ-22-8                                  	    ст. викл. Сокорчук І. П.
Кучерявенко К. Р. 






Харків 2024
2.1 Мета роботи
Опанувати основні методи рефакторингу коду на основі реальних прикладів з власних програмних проєктів. Навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.	
2.2 Хід роботи
	2.2.1 Посилання на YouTube

	URL: https://youtu.be/8duqNISVYVo

	2.2.2 Вступ

Рефакторинг — це процес удосконалення існуючого коду, який полягає в його модифікації з метою підвищення якості без зміни зовнішньої поведінки програми. Основною метою рефакторингу є покращення читабельності, структурованості та підтримуваності коду, що в свою чергу знижує ймовірність помилок і полегшує подальший розвиток проекту. Рефакторинг дозволяє розробникам впроваджувати нові функціональні можливості більш ефективно, зберігаючи при цьому стабільність і надійність програмного забезпечення.

2.2.3 Метод «Add Parameter»
Метод додавання параметра полягає у додаванні параметра до існуючого методу для зменшення його залежності від глобальних змінних або контексту, що покращує його гнучкість та повторне використання.
Розглянемо два фрагменти коду.
До:
1 public class Order {
2     private double discountRate;
3
4     public double calculateTotal(double price) {
5         return price - (price * discountRate);
6     }
7 }
Після:
1 public class Order {
2     public double calculateTotal(double price, double discountRate) {
3         return price - (price * discountRate);
4     }
5 }
У прикладі до є метод calculateTotal використовує змінну discountRate, яка виділена червоним кольором і є атрибутом класу Order. Це означає, що всі замовлення використовують одну й ту ж ставку знижки, якщо вона не змінюється в класі. Всякий раз, коли потрібно обчислити загальну вартість з різними ставками знижки, потрібно змінювати discountRate у класі, що може призвести до непередбачуваних результатів. Через це важко тестувати методи з різними значеннями знижок, оскільки вони залежать від стану об’єкта.
У варіанті після є метод calculateTotal приймає discountRate, що виділений зеленим кольором, як параметр. Це означає, що ми можемо передати різні ставки знижки без зміни атрибутів класу. Цим забезпечується гнучкість, легкість тестування та зменшення залежності від стану об’єкта. Маємо передавати різні ставки знижки при кожному виклику методу, можна легко протестувати метод з різними ставками знижки, не змінюючи стан об'єкта та метод не залежить від змінних класу, що робить його більш самодостатнім.

2.2.4 Метод «Decompose Conditional»

Метод розбиття умовного оператора полягає в розбитті складних умов на прості, щоб поліпшити читабельність коду. Це допомагає зрозуміти логіку програми і спростити тестування.
Розглянемо два фрагменти коду.
До
1 public void printOrderStatus(Order order) {
2     if (order.isPaid() && order.isShipped()) {
3         System.out.println("Order is paid and shipped.");
4     } else {
5         System.out.println("Order is not ready.");
6     }
7 }
Після
1 public void printOrderStatus(Order order) {
2     if (isOrderReady(order)) {
3         System.out.println("Order is paid and shipped.");
4     } else {
5         System.out.println("Order is not ready.");
6     }
7 }
8 
9 private boolean isOrderReady(Order order) {
10     return order.isPaid() && order.isShipped();
11 }
	В прикладі до є умова, яка виділена червоним, що перевіряє, чи було замовлення оплачено та відправлено. Хоча це може здаватися простим, логіка умовного виразу може стати заплутаною, якщо умови зростають ускладнення. Оскільки умова складається з двох перевірок, і якщо їх кількість зросте, код стане важким для розуміння. Також зміни в логіці умов можуть вимагати модифікації основного методу, що ускладнює його підтримку.
У варіанті після створено новий метод isOrderReady, який виділено зеленим кольором та відповідає за перевірку умов готовності замовлення. Метод printOrderStatus тепер містить лише одну умову, що робить його більш зрозумілим. Після змін код став легший для читання та розуміння, оскільки умова зведена до простого виклику методу. Логіка перевірки розділена на окремий метод, що полегшує її тестування та підтримку. Зміни в логіці перевірки готовності замовлення можна виконати в одному місці без необхідності змінювати основний метод.

2.2.5 Метод «Hide Method»

Метод приховування методу передбачає обмеження видимості деяких методів у класі, щоб зменшити їх доступність для зовнішнього коду. Це дозволяє захистити внутрішню логіку класу та зменшити можливість випадкового використання методів, які не призначені для зовнішнього використання.
Розглянемо два фрагменти коду.
1 До:
2 public class Account {
3     public void deposit(double amount) {
4         // logic to deposit amount
5     }
6 
7     public void calculateInterest() {
8         // logic to calculate interest
9     }
10 }
Після:
1 public class Account {
2     public void deposit(double amount) {
3         // logic to deposit amount
4     }
5
6     // Метод тепер закритий
7     private void calculateInterest() {
8         // logic to calculate interest
9     }
10 }
У коді до є публічний метод calculateInterest, тобто його можна викликати ззовні класу Account. Це може призвести до того, що інші класи або об'єкти можуть викликати цей метод без належного контролю, що може спричинити помилки або неочікувану поведінку. Зовнішні класи можуть випадково або навмисно викликати методи, які не призначені для них. Доступність методів може призвести до того, що зовнішній код може змінювати внутрішню логіку класу.
У варіанті  після метод calculateInterest став приватним. Тепер його не можна викликати ззовні класу Account, що захищає внутрішню логіку. Методи, які не призначені для зовнішнього використання, сховані, що дозволяє контролювати, які частини класу доступні іншим частинам програми. Інші класи не можуть випадково викликати методи, які можуть порушити цілісність об'єкта. Внутрішні зміни не впливають на зовнішні класи, які використовують Account, оскільки зміни не потребують коригування їх коду.

2.2.6 Покрокова демонстрація рефакторингу

Розглянемо початковий код без рефакторингу, на основі якого будемо робити рефакторинг. 
1. public class DiscountService {
2.     public double calculateDiscount(double totalPrice, boolean isSpecialCustomer) {
3.         if (isSpecialCustomer) {
4.             return totalPrice * 0.9;
5.         } else if (totalPrice > 100) {
6.             return totalPrice * 0.95;
7.         } else {
8.             return totalPrice;
9.         }
10.    }
11. }
Цей код є простим сервісом, який обчислює знижку для покупців. Клас DiscountService має метод calculateDiscount, що приймає два параметри: totalPrice – загальна сума покупки; isSpecialCustomer – булевий параметр, що вказує, чи є покупець спеціальним (наприклад, постійним або з привілеями).
Метод працює так:
–	якщо покупець є спеціальним (isSpecialCustomer == true), то надається знижка 10%, і повертається сума з урахуванням цієї знижки (totalPrice * 0.9);
–	якщо покупець не спеціальний, але сума покупки перевищує 100, застосовується знижка 5% (totalPrice * 0.95).
Якщо покупець не спеціальний і сума покупки не перевищує 100, повертається початкова сума (totalPrice), тобто знижка не застосовується. Цей метод вибирає відповідну знижку на основі умов, зазначених вище.
Перейдемо до першого кроку демонстрація рефакторингу.
Для початку вирішимо, як провести рефакторинг коду, щоб:
–	зменшити залежність від глобальних змінних;
– 	поліпшити читабельність та структуру умовних операторів;
–	спростити інтерфейс класу, приховавши непотрібні методи.
Для цього обираємо методи додавання параметра, розбиття умовного оператора та приховування методу. 
Далі треба проаналізувати вихідний код та визначити проблеми. Проблеми:
–	Відсутня можливість задавати індивідуальні знижки, оскільки він не приймає параметр для зміни відсотка знижки.
–	Використання булевого параметра для визначення статусу покупця є жорстким і не дозволяє гнучко керувати різними типами клієнтів.
–	Логіка знижки на основі порогу вартості є статичною, що може призводити до ігнорування інших важливих факторів, таких як тип продукту або сезонні знижки.
–	Код не перевіряє, чи є totalPrice негативним або нульовим, що може призвести до непередбачуваних результатів.
–	Код важко розширити для додавання нових умов або типів знижок без значного переписування методу.
Почнемо з додавання параметра для відсотка знижки. Додавання параметра discountRate дозволяє задавати знижки для спеціальних клієнтів, що забезпечує гнучкість і можливість використовувати різні відсотки знижок, які можуть змінюватися залежно від умов.
1. public class DiscountService {
2.     public double calculateDiscount(double totalPrice, boolean isSpecialCustomer, double discountRate) {
3.         if (isSpecialCustomer) {
4.             return totalPrice * (1 - discountRate);
5.         } else if (totalPrice > 100) {
6.             return totalPrice * 0.95;
7.         } else {
8.             return totalPrice;
9.         }
10.    }
11. }
Далі створимо стратегію для клієнтів. Заміна булевого параметра на інтерфейс Customer робить код більш гнучким і розширюваним, дозволяючи додавати нові типи клієнтів з різними правилами надання знижок без необхідності переписувати метод.
1. public interface Customer {
2.     boolean isSpecial();
3.     double getDiscountRate();
4. }
5. 
6. public class DiscountService {
7.     public double calculateDiscount(double totalPrice, Customer customer) {
8.         if (customer.isSpecial()) {
9.             return totalPrice * (1 - customer.getDiscountRate());
10.        } else if (totalPrice > 100) {
11.            return totalPrice * 0.95;
12.        } else {
13.            return totalPrice;
14.        }
15.    }
16. }
Внесемо зміни до знижок. Додавання параметра isSeasonalSale і обробка сезонних знижок забезпечує можливість врахування додаткових факторів, що може покращити маркетингові стратегії і підвищити продажі під час акцій.
1. public interface Customer {
2.     boolean isSpecial();
3.     double getDiscountRate();
4. }
5. 
6. public class DiscountService {
7.     public double calculateDiscount(double totalPrice, Customer customer, boolean isSeasonalSale) {
8.         double discount = 0;
9. 
10.        if (customer.isSpecial()) {
11.            discount = customer.getDiscountRate();
12.        } else if (totalPrice > 100) {
13.            discount = 0.05; // 5% знижка
14.        }
15. 
16.        if (isSeasonalSale) {
17.            discount += 0.05; // Додаткова 5% знижка під час розпродажу
18.        }
19. 
20.        return totalPrice * (1 - discount);
21.    }
22. }
Додамо перевірку вхідних даних. Включення валідації для totalPrice запобігає можливості обробки некоректних даних, таких як негативні значення, що підвищує надійність і безпеку методу.
1. public interface Customer {
2.     boolean isSpecial();
3.     double getDiscountRate();
4. }
5. 
6. public class DiscountService {
7.     public double calculateDiscount(double totalPrice, Customer customer, boolean isSeasonalSale) {
8.         double discount = 0;
9. 
10.        if (customer.isSpecial()) {
11.            discount = customer.getDiscountRate();
12.        } else if (totalPrice > 100) {
13.            discount = 0.05; // 5% знижка
14.        }
15. 
16.        if (isSeasonalSale) {
17.            discount += 0.05; // Додаткова 5% знижка під час розпродажу
18.        }
19. 
20.        return totalPrice * (1 - discount);
21.    }
22. }
Розбиваємо метод на підметоди. Розділення методу calculateDiscount на кілька підметодів покращує читабельність і підтримуваність коду, дозволяючи легше зрозуміти логіку знижок та спростити тестування окремих частин.
	1. public interface Customer {
2.     boolean isSpecial();
3.     double getDiscountRate();
4. }
5. 
6. public class DiscountService {
7.     public double calculateDiscount(double totalPrice, Customer customer, boolean isSeasonalSale) {
8.         if (totalPrice < 0) {
9.             throw new IllegalArgumentException("Total price cannot be negative.");
10.        }
11. 
12.        double discount = calculateDiscountRate(totalPrice, customer);
13.        if (isSeasonalSale) {
14.            discount += 0.05; // Додаткова 5% знижка під час розпродажу
15.        }
16. 
17.        return applyDiscount(totalPrice, discount);
18.    }
19. 
20.  private double calculateDiscountRate(double totalPrice, Customer customer) {
21.        if (customer.isSpecial()) {
22.            return customer.getDiscountRate();
23.        } else if (totalPrice > 100) {
24.            return 0.05; // 5% знижка
25.        }
26.        return 0; // Немає знижки
27.    }
28. 
29.    private double applyDiscount(double totalPrice, double discount) {
30.        return totalPrice * (1 - discount);
31.    }
32. }
Після виконання рефакторингу отримали читабельний, простий і гнучкий код. 
1. public interface Customer {
2.     boolean isSpecial(); // Інтерфейс для різних типів клієнтів
3.     double getDiscountRate(); // Метод для отримання знижки спеціального клієнта
4. }
5. 
6. public class DiscountService {
7.     // Метод «Add Parameter»: Додаємо параметр isSeasonalSale для обробки сезонних знижок.
8.     public double calculateDiscount(double totalPrice, Customer customer, boolean isSeasonalSale) {
9.         // Перевірка вхідних даних для забезпечення коректності
10.        if (totalPrice < 0) {
11.            throw new IllegalArgumentException("Total price cannot be negative.");
12.        }
13. 
14.        // Метод «Decompose Conditional»: Витягуємо обчислення знижки в окремий метод для спрощення логіки
15.        double discount = calculateDiscountRate(totalPrice, customer);
16.        if (isSeasonalSale) {
17.            discount += 0.05; // Додаткова 5% знижка під час розпродажу
18.        }
19. 
20.        // Метод «Hide Method»: Обробка застосування знижки в окремому методі для полегшення тестування
21.        return applyDiscount(totalPrice, discount);
22.    }
23. 
24.    // Метод «Decompose Conditional»: Витягуємо логіку обчислення знижки в окремий метод
25.    private double calculateDiscountRate(double totalPrice, Customer customer) {
26.        if (customer.isSpecial()) {
27.            return customer.getDiscountRate();
28.        } else if (totalPrice > 100) {
29.            return 0.05; // 5% знижка
30.        }
31.        return 0; // Немає знижки
32.    }
33. 
34.    // Метод «Hide Method»: Метод для застосування знижки
35.    private double applyDiscount(double totalPrice, double discount) {
36.        return totalPrice * (1 - discount);
37.    }
38. }
Метод «Add Parameter»: додавання параметра isSeasonalSale для гнучкого управління знижками.
Метод «Decompose Conditional»: витягування обчислення знижки в метод calculateDiscountRate, що спрощує основний метод calculateDiscount.
Метод «Hide Method»: витягування логіки застосування знижки в окремий метод applyDiscount для підвищення читабельності та можливості тестування.

2.2.7 Інструменти для рефакторингу

Сучасні інтегровані середовища розробки (IDE) пропонують потужні інструменти для рефакторингу, що робить цю задачу більш ефективною. Розглянемо трьох популярних IDE: IntelliJ IDEA, Visual Studio та Eclipse.
IntelliJ IDEA від JetBrains — це одне з найбільш популярних середовищ для розробки Java, яке також підтримує інші мови програмування. Інструменти рефакторингу в IDEA включають автоматичне перейменування, вилучення методів, інлайнінг, переміщення класів і методів, а також зміну сигнатур методів. IDEA використовує розумні аналізи коду для виявлення можливостей для рефакторингу, що спрощує роботу розробників.
Visual Studio — це потужна IDE від Microsoft, орієнтована на розробку додатків для Windows та вебу. Вона пропонує різноманітні інструменти для рефакторингу, включаючи автоматичне перейменування, вилучення методів, видалення невикористовуваних коду, а також зміни в структурі проекту. Завдяки інтеграції з Azure DevOps та іншими сервісами, Visual Studio дозволяє легко працювати з кодом у команді.
Eclipse — це безкоштовна та відкритоджерельна IDE, популярна серед Java-розробників. Eclipse надає базові можливості для рефакторингу, такі як перейменування, переміщення класів, вилучення методів і зміна сигнатур методів. Хоча Eclipse може бути менш інтуїтивно зрозумілою у порівнянні з IDEA, вона все ще залишається популярним вибором завдяки своїй гнучкості та розширюваності.

Висновки: 
Рефакторинг є важливим етапом у розробці програмного забезпечення, оскільки він покращує читабельність коду, роблячи його легшим для розуміння. Це також зменшує технічний борг, запобігаючи накопиченню проблем у коді. Чистіший код полегшує тестування, сприяючи швидшому виявленню помилок, а також підвищує продуктивність, оптимізуючи роботу програми. Рефакторинг варто застосовувати після внесення нових функцій для перевірки структури коду, при підвищенні складності, щоб спростити занадто складний код, перед значними змінами для підготовки до масштабних оновлень, а також під час написання тестів, що допомагає виявити частини коду, які потребують поліпшення. 
Перелік джерел посилання


1.Фаулер М. Refactoring: Improving the Design of Existing Code (2-е видання). Адісон-Веслі, 2018. 448 с.
2. Мартін Р. Clean Code: A Handbook of Agile Software Craftsmanship. Прентис Холл, 2018. 464 с.
3.Макконнелл С. Code Complete. Майкрософт Пресс, 2020. 896 с.
4. Хант Е., Томас Д. The Pragmatic Programmer. Аддісон-Веслі, 2020. 368 с.
5. Refactoring.Guru. 2024.
URL: https://refactoring.guru/
 
Додаток А


 
Рисунок А.1 – Титульний слайд

 
Рисунок А.2 – Слайд зі змістом
 
Рисунок А.3 – Слайд зі вступом

 
Рисунок А.4 – Слайд з методом «Додавання параметра» 

 
Рисунок А.5 – Слайд з прикладом 

 
Рисунок А.6 – Слайд з методом «Розбиття умовного оператора»

 
Рисунок А.7 – Слайд з прикладом

 
Рисунок А.8 – Слайд з методом «Приховування методу»

 
Рисунок А.9 – Слайд з прикладом

 
Рисунок А.10 – Слайд з кодом до рефакторингу

 
Рисунок А.11 – Слайд про обирання методу

 
Рисунок А.12 – Слайд з аналізом вихідного коду

 
Рисунок А.13 – Слайд про зміни в коді

 
Рисунок А.14 – Слайд з додаванням параметрів знижки до коду

 
Рисунок А.15 – Слайд з використанням стратегії для клієнтів до коду

 
Рисунок А.16 – Слайд з запровадженням більш складної логіки знижок до коду

 
Рисунок А.17 – Слайд з додаванням перевірки вхідних даних до коду

 
Рисунок А.18 – Слайд з розбиттям методів у коді

 
Рисунок А.19 – Слайд з результатом рефакторингу

 
Рисунок А.20 – Слайд про інструменти рефакторингу

 
Рисунок А.21 – Слайд з висновками

 
Рисунок А.22 – Слайд зі списком використаних джерел

