Міністерство освіти і науки України
Харківський національний університет радіоелектроніки



Кафедра програмної інженерії





Звіт
з практичної роботи №1
з дисципліни  «Аналіз та рефакторінг коду»
на тему «Правила оформлення програмного коду
для Python»





Виконала:						    Перевірив:
Ст. гр. ПЗПІ-22-8                                  	    ст. викл. Сокорчук І. П.
Кучерявенко К. Р. 





Харків 2024
1.1 Мета роботи
Опанувати методи аналізу та оцінювання якості програмного коду. Навчитися визначати проблемні ділянки коду та обирати відповідні методи рефакторингу для їх усунення. Застосовувати ефективні підходи до підвищення читабельності та зменшення складності коду. Освоїти техніки покращення архітектури програмного забезпечення без зміни його зовнішньої функціональності. Підвищити свої практичні навички роботи з сучасними мовами програмування та інструментами для рефакторингу коду.
	
1.2 Хід роботи
	1.2.1 Посилання на YouTube
	URL: https://youtu.be/sCufehXgSxA

	1.2.2 Особливості мови Python

Python – це потужна, універсальна та надзвичайно популярна мова програмування, відома своєю простотою та читабельністю. Вона широко використовується в різних галузях, від веб-розробки до наукових обчислень і машинного навчання.
Python набув свою популярність через: простоту синтаксису, багатофункціональність, велике співтовариство, інтерпретованість, Об'єктно-орієнтованість. 
Код Python легко читати і писати,  що робить його ідеальним для початківців. Завдяки великій кількості бібліотек, Python можна використовувати для вирішення різноманітних задач. Код виконується рядок за рядком, що полегшує налагодження. Python підтримує парадигму об'єктно-орієнтованого програмування, що дозволяє створювати структурований і повторно використовуваний код.
Активна спільнота розробників забезпечує постійний розвиток мови та доступність великої кількості ресурсів для навчання.

1.2.3 Основні рекомендації для написання коду

Весь код на мові програмування Python пишеться відповідно до загальноприйнятого стилю, викладеного в документі PEP 8. Відповідність якомусь єдиному стандарту необхідна для підвищення читання та розуміння коду як самим автором, так і іншими програмістами.
PEP 8 – це фундаментальний документ, який визначає офіційний стиль кодування для Python. Дотримання цих рекомендацій робить код більш читабельним, зрозумілим для інших розробників та полегшує його підтримку в майбутньому. Розглянемо основні загальні правила.
Перше правило – вибір зрозумілих імен для змінних, функцій, класів. Чіткі імена змінних та функцій допомагають зрозуміти призначення коду без додаткових коментарів. Погано названі змінні або функції роблять код важким для читання, особливо при його підтримці іншими розробниками. Зрозумілі імена полегшують внесення змін у майбутньому, особливо в складних проєктах або при командній роботі. 

1 # Поганий приклад
2 def f(x, y):
3     return x + y
4 
5 # Гарний приклад
6 def calculate_sum(a, b):
7     return a + b

Розглянемо функцію додавання як приклад. У першому варіанті функція позначена літерою "Ф" та має два аргументи, які можуть бути помилково сприйняті за координати. Це ускладнює розуміння призначення функції. У другому варіанті ми маємо явну назву "додавання" та використовуємо традиційні змінні "a" та "b" для чисел, що додаються. Така форма запису є більш зрозумілою та відповідає загальноприйнятим математичним позначенням.
Конвенції іменування полегшують читання та розуміння коду. Розглянемо правила іменування. 
Назви класів пишемо верблюдячим регістром: MyClass, UserInterface.
Назви змінних вказуємо зміїним регістром у нижньому регістрі: first_name, current_age.
Назви функцій теж пишемо зміїним регістром у нижньому регістрі: calculate_area(), sort_array().
Назви констант — зміїним регістром у верхньому регістрі: PI, MAX_VALUE.
Модулі слід називати коротко й зміїним регістром у нижньому регістрі: numpy, pandas.

1  # Поганий приклад
2  class myclass:
3      def QuickSort(arr):
4          Pi = 3.14159
5          for item in Arr:
6              print(item)
7      def Printname(Name):
8          print(Name)
9  
10 firstName = "John"
11 my_class_instance = myclass()
12 myclass().QuickSort([1, 2, 3])
13 myclass().Printname(firstName)
14
15 # Гарний приклад
16 class MyClass:
17     PI = 3.14159  # Константа у верхньому регістрі
18 
19     def quick_sort(self, arr):
20         """Виводить елементи масиву в порядку сортування."""
21         for item in arr:
22             print(item)
23 
24     def print_name(self, name):
25         """Друкує ім'я."""
26         print(name)
27 
28 first_name = "John"  # Змінна у зміїному регістрі
29 my_class_instance = MyClass()
30 my_class_instance.quick_sort([1, 2, 3])
31 my_class_instance.print_name(first_name)

Поганий приклад демонструє відсутність будь-яких стандартів у найменуванні класів, змінних і функцій. Такий підхід суттєво ускладнює читання та розуміння коду. Константи, такі як Pi, зазвичай пишуться великими літерами, а змінні та функції – малими. Крім того, відсутність коментарів не дозволяє зрозуміти призначення функцій, а відсутність відступів робить код важким для візуального сприйняття.
У гарному прикладі ці недоліки усунуто. Імена елементів коду приведені до єдиного стилю, додані коментарі, що пояснюють логіку програми.
Коментарі є невід'ємною частиною якісного коду. Вони допомагають зрозуміти логіку роботи програми, призначення окремих функцій та класів. Чітка документація спрощує співпрацю над проектом, прискорює розробку та підтримку програмного забезпечення.
Відсутність або неякісні коментарі можуть призвести до значних труднощів при: розумінні коду, виправленні помилок та розширенні функціоналу.

1  # Поганий приклад
2  def calculate_area(width, height):
3      return width * height  # Обчислює площу
4
5  # Гарний приклад
6  def calculate_area(width, height):
7      """
8      Обчислює площу прямокутника.
9      
10      :param width: Ширина прямокутника
11     :param height: Висота прямокутника
12     :return: Площа прямокутника
13     """
14     return width * height

В поганому прикладі функція обчислює площу, але не вказано, площу якої саме фігури. Це ускладнює розуміння її використання. В хорошому прикладі вказано, що функція обчислює площу прямокутника. Вона приймає два параметри: довжину та ширину. Результатом роботи функції є числове значення, що представляє площу прямокутника.
Чітка структура та відступи полегшують читання та розуміння коду. Це також допомагає швидше знайти помилки і робить код легким для читання й модифікації, особливо коли проєкт збільшується. Неформатований код важко читати, аналізувати та підтримувати. 

1  # Поганий приклад
2  def calculate_area(width, height):
3      return width * height
4  
5  def print_area():
6      width = 5
7      height = 10
8      print(calculate_area(width, height))
9  
10 # Гарний приклад
11 def calculate_area(width, height):
12     return width * height
13 
14 def print_area():
15     width = 5
16     height = 10
17     print(calculate_area(width, height))

В першому прикладі код важко читати, оскільки не видно, яка частина коду належить до якої функції. Це може призвести до помилок при написанні та розумінні коду. Об'єднання оголошення змінних і виклику функції в одному рядку ускладнює розуміння програми.
В другому прикладі чітко видно, де починається і закінчується кожна функція. Це робить код більш структурованим і легким для розуміння. Є розділення між оголошенням змінних та виклику функцій. Кожна дія відбувається на окремому рядку, що підвищує читабельність коду.

1.2.4 Оформлення функцій та методів

Чіткі та невеликі функції легше розуміти, тестувати й підтримувати. Великі функції, які виконують багато завдань, складно тестувати та налагоджувати. Короткі та чітко визначені функції дозволяють швидше знаходити проблеми та полегшують масштабування коду.

1  # Поганий приклад
2  def process_data(data):
3    # Обробка даних, підрахунок, логіка, перевірки...
4    # Функція містить кілька різних завдань
5    result = []
6    for item in data:
7      if item > 10:
8        result.append(item)
9    return result
10
11 # Гарний приклад
12 def filter_large_values(data, threshold=10):
13  """Повертає елементи більші за threshold."""
14  return [item for item in data if item > threshold]

В поганому прикладі функція process_data виконує кілька завдань (обробка даних, підрахунки, перевірки), що робить її складною для розуміння і підтримки. Також незрозуміло, що саме робить функція або які дані вона обробляє. В гарному прикладі функція filter_large_values виконує одну чітку задачу — фільтрує значення, що перевищують порогове значення (threshold). Функція має короткий і зрозумілий опис.
Назва функції повинна відображати її призначення для зрозумілості. Правильна назва функції дозволяє швидше зрозуміти логіку програми та зменшує час на підтримку. Неясна назва змушує програміста додатково вивчати, що робить функція. 

1 # Поганий приклад
2 def do_it(data):
3  return sorted(data)
4
5 # Гарний приклад
6 def sort_data(data):
7   """Сортує список даних."""
8    return sorted(data)

В поганому прикладі функція do_it має невизначену назву, яка не пояснює, що робить функція. Функція sort_data має зрозумілу назву, яка чітко вказує на те, що відбувається сортування даних. Також є документація, що пояснює призначення функції.
Дотримання узгоджених шаблонів для схожих функцій важливе з кількох причин. 
По-перше, у Python, як і в інших мовах, читабельність коду є критично важливою. Однакові шаблони функцій допомагають програмістам швидше розуміти структуру і призначення коду, навіть якщо функції виконують різні завдання. 
По-друге, непослідовність у написанні схожих функцій ускладнює читання і налагодження коду. Якщо програмісти постійно змінюють стиль оформлення функцій, інші можуть заплутатись, особливо в великих проєктах, що підвищує ризик помилок і довшого часу на налагодження.
Узгодженість полегшує підтримку коду в майбутньому. Коли функції мають однакову структуру та стиль, легше робити зміни або додавати нові функції, не витрачаючи зайвий час на те, щоб зрозуміти, як саме написана кожна частина. Це також сприяє тому, що код стає більш доступним для нових розробників або тих, хто повертається до старого проєкту.

1 # Поганий приклад 
 2 def add_user(username, email):
 3   print("User added:", username)
 4   # Логіка додавання користувача
 5   pass
 6 
 7 def removeUser(user_id):
 8   print("User removed:", user_id)
 9   # Логіка видалення користувача
10   pass
11 
12 def EditProfile(user_name, Email):
13   print("Profile updated for:", user_name)
14   # Логіка оновлення профілю
15   Pass
16 
17 # Гарний приклад
18 def add_user(username, email):
19   """
20   Додає нового користувача з ім'ям та електронною поштою.
21   
22   :param username: Ім'я користувача
23   :param email: Електронна пошта користувача
24   """
25   print("User added:", username)
26   # Логіка додавання користувача
27   pass
28 
29 def remove_user(user_id):
30   """
31   Видаляє користувача за його ID.
32   
33   :param user_id: Ідентифікатор користувача
34   """
35   print("User removed:", user_id)
36   # Логіка видалення користувача
37   pass
38 
39 def edit_profile(username, email):
40   """
41   Оновлює профіль користувача.
42   
43   :param username: Ім'я користувача
44   :param email: Оновлена електронна пошта
45   """
46   print("Profile updated for:", username)
47   # Логіка оновлення профілю
48   pass

В поганому прикладі функції мають недотримані стилі оформлення, наприклад, різні регістри в назвах функцій (removeUser, EditProfile). Немає опису параметрів і логіки. В іншому прикладі усі функції мають однаковий стиль у назвах, а саме зміїний регістр, додана документація для кожної функції, яка пояснює призначення та параметри.

1.2.5 Форматування коду

Python використовує відступи для визначення блоків коду, тому правильне їх використання є критичним для правильного виконання програми. Правильні відступи роблять код більш читабельним і допомагають уникнути помилок. Неправильні відступи можуть призвести до помилок синтаксису або некоректної роботи програми. 

1 # Поганий приклад
2 def calculate_area(width, height):
3  return width * height

4 # Гарний приклад
5 def calculate_area(width, height):
6     return width * height

В поганому прикладі після ключових слів на рівні кодування має бути 4 пробіли для відступу. Один пробіл перед return у прикладі — це помилко. Гарний приклад містить правильний відступ у 4 пробіли.
В Python не потрібні круглі дужки для умовних операторів, і краще не використовувати їх, якщо це не потрібно для покращення читабельності. Використання зайвих дужок ускладнює код без реальної потреби.

1 # Поганий приклад
 2 if(a==b):
 3   print("Equal")
 4 data = {1, 2, 3, 4}
 5 
 6 # Гарний приклад
 7 if a == b:
 8   print("Equal")
 9 data = {
10     'name': 'John',
11     'age': 30, 
12     'country': 'USA' 
13 }
14 unique_numbers = {1, 2, 3, 4}

В поганому прикладі умовна конструкція написана без пробілів між операторами, а множини та словники написані без чіткої структури. В гарному прикладі структура коду більш читабельна: додані пробіли між операторами, а словники й множини оформлені у зручному для читання форматі.
Вирівнювання операторів дозволяє легко розрізняти частини виразів і спрощує розуміння математичних операцій. Чітке вирівнювання виразів зменшує кількість помилок та спрощує підтримку коду в довгостроковій перспективі. Невідповідне вирівнювання може призвести до помилок у розрахунках або неправильного трактування коду.

1 # Поганий приклад
 2 result=a+b-c*d/e
 3 
 4 result = a + b + c * d - e / f + (g + h / i)
 5 total = x * y + z / w
 6 
 7 # Гарний приклад
 8 result = ((a + b) * c) - (d / e)
 9 
10 result = a + b + c * d - e / f + (g + h / i)
11 total  = x * y + z / w

У поганому прикладі використання операторів без пробілів робить код важким для розуміння, особливо у великих виразах. У гарному прикладі додані пробіли між операторами та вирівняні вирази. Це полегшує сприйняття та зменшує ризик помилок при редагуванні. 

1.2.6 Приклад коду до та після застосування правил оформлення
	
	1 # Поганий приклад
 2 def proc(a,b):
 3  for i in range(a):
 4  for j in range(b):
 5   if i%2==0:print("Even",i)
 6  else:print("Odd",j)
 7  sum=0
 8  for i in range(a):sum+=i
 9  if sum>50:return sum/2
10  else:return sum
11 a=10;b=20;res=proc(a,b);print("Result:",res)
12 
13 # Гарний приклад
14 def process_data(rows, cols):
15   """
16   Обробляє матрицю та підраховує суму індексів рядків.
17   
18   :param rows: Кількість рядків
19   :param cols: Кількість стовпців
20   :return: Сума індексів рядків
21   """
22   for i in range(rows):
23     for j in range(cols):
24       if i % 2 == 0:
25         print("Even row:", i)
26       else:
27         print("Odd column:", j)
28   
29   total_sum = 0
30   for i in range(rows):
31     total_sum += i
32   
33   if total_sum > 50:
34     return total_sum / 2
35   else:
36     return total_sum

У поганому прикладі код має кілька суттєвих недоліків.
1. Назва функції та змінних. Функція proc і змінні a, b, sum використовують короткі, неінформативні назви. Це робить код менш зрозумілим і складним для підтримки.
2. Відступи. Відступи в коді не дотримані належним чином. Наприклад, блоки for і if-else мають неправильні відступи, що робить код візуально непривабливим і складним для читання.
3. Однорядкові цикли. Цикл, що підсумовує значення (for i in range(a): sum+=i), записаний в одному рядку, що ускладнює його розуміння та налагодження.
4. Стиль та форматування. Відсутність пробілів між операторами (i%2==0) робить код важким для сприйняття.
5. Виклик функції. Використання змінних a та b у виклику функції без будь-якого контексту чи пояснення ускладнює розуміння, для чого саме вони потрібні.
Порівняємо з гарним прикладом.
1. Назви функцій і змінних. У гарному прикладі функція названа process_data, що чітко пояснює її призначення, а змінні rows та cols дають зрозуміти, що це кількість рядків і стовпців матриці.
2. Правильні відступи. У гарному прикладі відступи дотримані відповідно до стандартів Python (PEP8), що робить код чистим і зручним для читання.
3.  Документація. Додана документація до функції пояснює її призначення та параметри, що полегшує розуміння та підтримку коду.
4. Логіка розподілена на окремі рядки. Цикл підрахунку суми індексів розділений на кілька рядків, що спрощує його сприйняття та налагодження.
5. Стиль та форматування. У гарному прикладі дотримані пробіли навколо операторів, що робить код більш читабельним.

Висновки: Поганий код виглядає хаотично, його важко читати і підтримувати. Добрий код, навпаки, структурований і легко розуміється. Дотримання стандартів форматування робить код не тільки красивим, але і функціонально надійним, що полегшує його розширення і подальшу підтримку.
 
Перелік джерел посилання


1. PEP 8 – Посібник зі стилю для коду Python. 2024.
URL: https://peps.python.org/pep-0008/
2. Чистий Python-код: основи. 2024.
URL: https://devzone.org.ua/post/chystyy-python-kod-osnovy
3. Огляд стилів коду в мові програмування Python. 2024.
URL: https://www.vitaliypodoba.com/2014/07/python-style-guide/
4. Python - Вікіпедія. 2024.
URL: https://uk.wikipedia.org/wiki/Python

 
Додаток А


 
Рисунок А.1 – Титульний слайд презентації

 
Рисунок А.2 – Слайд зі зміст презентації

 
Рисунок А.3 – Слайд  про особливості мови Python

 
Рисунок А.4 – Слайд з інформацією про РЕР 8

 
Рисунок А.5 – Слайд з прикладом вибору зрозумілих імен

 
Рисунок А.6 – Слайд з прикладом конвекції іменування

 
Рисунок А.7 – Слайд з прикладом коментарів до коду

 
Рисунок А.8 – Слайд з прикладом структурування коду

 
Рисунок А.9 – Слайд з прикладом створенням функцій

 
Рисунок А.10 – Слайд з прикладом відповідності імен

 
Рисунок А.11 – Слайд з поганим прикладом використанням шаблонів для схожих функцій

 
Рисунок А.12 – Слайд з гарним прикладом використанням шаблонів для схожих функцій

 
Рисунок А.13 – Слайд з прикладом відступів

 
Рисунок А.14 – Слайд з прикладом використання круглих і фігурних дужок

 
Рисунок А.15 – Слайд з прикладом вирівнювання операторів та виразів

 
Рисунок А.16 – Слайд з прикладом коду до застосування правил оформлення

 
Рисунок А.17 – Слайд з прикладом коду після застосування правил оформлення

 
Рисунок А.18 – Слайд з висновками

 
Рисунок А.19 – Слайд зі списком використаних джерел
